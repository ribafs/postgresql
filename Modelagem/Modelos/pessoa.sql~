/*
Banco: pessoa

Cenário:
Modelagem de pessoas (clientes, funcionários, fornecedores, etc) para empresas, órgãos públicos ou outras instituições brasileiras.

Usando o Moedelo Relacional Normalizado (no SGBD PostgreSQL).
*/

-- Função de validação do CPF e CNPJ:

-- *****************************************************
-- Função: f_cnpjcpf
-- Objetivo:
-- Validar o número do documento especificado
-- (CNPJ ou CPF) ou não (livre)
-- Argumentos:
-- Pessoa 
-- Jurídica(0),
-- Física(1) ou 
-- Livre(2)] (integer), 
-- Número com dígitos verificadores e sem pontuação (bpchar)
-- Retorno:
-- -1: Tipo de Documento invalido.
-- -2: Caracter inválido no numero do documento.
-- -3: Numero do Documento invalido.
--  1: OK (smallint)
-- *****************************************************
--
/*
-- Número com dígitos verificadores e sem nenhuma máscara (bpchar)

-- Válidos
SELECT f_cnpjcpf( 0, '46376021000107' );-- CNPJ
SELECT f_cnpjcpf( 1, '48533316461' ); 	-- CPF
SELECT f_cnpjcpf( 2, 'isento' );      	-- Livre 

-- Inválidos
SELECT f_cnpjcpf( 0, '46376044444107' );-- CNPJ
SELECT f_cnpjcpf( 1, '40003316461' ); 	-- CPF
SELECT f_cnpjcpf( 2, 'isento' );      	-- Livre 

Retornos possíveis:
-- -1: Tipo de Documento invalido.
-- -2: Caracter inválido no numero do documento.
-- -3: Numero do Documento invalido.
--  1: Documento Validado Corretamente - OK (smallint)
*/

create language plpgsql;

CREATE OR REPLACE FUNCTION f_cnpjcpf (integer,bpchar)
RETURNS integer
AS '
DECLARE
-- Argumentos
-- Tipo de verificacao : 0 (PJ), 1 (PF) e 2 (Livre)
   pTipo ALIAS FOR $1;
-- Numero do documento
   pNumero ALIAS FOR $2;
-- Variaveis
   i INT4; -- Contador
   iProd INT4; -- Somatório
   iMult INT4; -- Fator
   iDigito INT4; -- Digito verificador calculado
   sNumero VARCHAR(20); -- numero do docto completo
BEGIN
-- verifica Argumentos validos
   IF (pTipo < 0) OR (pTipo > 2) THEN
      RETURN -1;
   END IF;
-- se for Livre, nao eh necessario a verificacao
  IF pTipo = 2 THEN
    RETURN 1;
  END IF;
  sNumero := trim(pNumero);
  FOR i IN 1..char_length(sNumero) LOOP
    IF position(substring(sNumero, i, 1) in ''1234567890'') = 0 THEN
       RETURN -2;
    END IF;
  END LOOP;
  sNumero := '''';
-- *****************************************************
-- Verifica a validade do CNPJ
-- *****************************************************
  IF (char_length(trim(pNumero)) = 14) AND (pTipo = 0) THEN
-- primeiro digito
    sNumero := substring(pNumero from 1 for 12);
    iMult := 2;
    iProd := 0;
    FOR i IN REVERSE 12..1 LOOP
       iProd := iProd + to_number(substring(sNumero from i for 1),''9'') * iMult;
       IF iMult = 9 THEN
         iMult := 2;
       ELSE
         iMult := iMult + 1;
       END IF;
    END LOOP;
    iDigito := 11 - (iProd % 11);
    IF iDigito >= 10 THEN
       iDigito := 0;
    END IF;
    sNumero := substring(pNumero from 1 for 12) || trim(to_char(iDigito,''9'')) || ''0'';
-- segundo digito
    iMult := 2;
    iProd := 0;
    FOR i IN REVERSE 13..1 LOOP
       iProd := iProd + to_number(substring(sNumero from i for 1),''9'') * iMult;
       IF iMult = 9 THEN
         iMult := 2;
       ELSE
         iMult := iMult + 1;
       END IF;
     END LOOP;
     iDigito := 11 - (iProd % 11);
     IF iDigito >= 10 THEN
       iDigito := 0;
     END IF;
     sNumero := substring(sNumero from 1 for 13) || trim(to_char(iDigito,''9''));
  END IF;
-- *****************************************************
-- Verifica a validade do CPF
-- *****************************************************
  IF (char_length(trim(pNumero)) = 11) AND (pTipo = 1) THEN
-- primeiro digito
     iDigito := 0;
     iProd := 0;
     sNumero := substring(pNumero from 1 for 9);
     FOR i IN 1..9 LOOP
       iProd := iProd + (to_number(substring(sNumero from i for 1),''9'') * (11 - i));
     END LOOP;
     iDigito := 11 - (iProd % 11);
     IF (iDigito) >= 10 THEN
       iDigito := 0;
     END IF;
     sNumero := substring(pNumero from 1 for 9) || trim(to_char(iDigito,''9'')) || ''0'';
-- segundo digito
     iProd := 0;
     FOR i IN 1..10 LOOP
       iProd := iProd + (to_number(substring(sNumero from i for 1),''9'') * (12 - i));
     END LOOP;
     iDigito := 11 - (iProd % 11);
     IF (iDigito) >= 10 THEN
       iDigito := 0;
     END IF;
     sNumero := substring(sNumero from 1 for 10) || trim(to_char(iDigito,''9''));
  END IF;
-- faz a verificacao do digito verificador calculado
  IF pNumero = sNumero::bpchar THEN
    RETURN 1;
   ELSE
    RETURN -3;
   END IF;
END;
' LANGUAGE 'plpgsql';

-- Esta função acima é do Juliano Ignácio num dos seus artigos do iMasters:
-- http://imasters.uol.com.br/artigo/1308/stored_procedures_triggers_functions


-- Validação de inscrição estadual do Ceará, tendo como fonte o algoritmo em: http://www.sintegra.gov.br/Cad_Estados/cad_CE.html
-- No Ceará a IE tem 8 dígitos válidos mais o dígito verificador

create or replace function ie_ce(ie_ce text) returns text as
$$
declare
	n1 int;
	n2 int;	
	n3 int;
	n4 int;
	n5 int;
	n6 int;
	n7 int;
	n8 int;
	n9 int;
	nt int;
	s int;
	m int;
	dv int;
begin
	n1 = substring(ie_ce from 1 for 1)::integer;
	n2 = substring(ie_ce from 2 for 1)::integer;
	n3 = substring(ie_ce from 3 for 1)::integer;
	n4 = substring(ie_ce from 4 for 1)::integer;
	n5 = substring(ie_ce from 5 for 1)::integer;
	n6 = substring(ie_ce from 6 for 1)::integer;
	n7 = substring(ie_ce from 7 for 1)::integer;
	n8 = substring(ie_ce from 8 for 1)::integer;
	n9 = substring(ie_ce from 9 for 1)::integer;
	s = 9*n1 + 8*n2 + 7*n3 + 6*n4 + 5*n5 + 4*n6 + 3*n7 + 2*n8;
	m = s%11;
	dv = 11 - m;
	-- raise exception 'm vale(%), dv vale(%), n6(%)',m,dv, n6; 
	if (dv = n9) then
		return 1;
	else
		return 0;
	end if;
end;
$$
language 'plpgsql';	

-- select ie_ce('060000014')

-- Função para gerar uma inscrição estadual (do Ceará) válida para testes

create or replace function ie_ce_gerador() returns text as
$$
declare
	ie_ce text;
	n1 integer;
	n2 integer;	
	n3 integer;
	n4 integer;
	n5 integer;
	n6 integer;
	n7 integer;
	n8 integer;
	n9 integer;
	nt integer;
	s  integer;
	m  integer;
	dv integer;
	d boolean;
begin
	d = FALSE;
	while (d = FALSE) loop
	ie_ce = floor(random()*1000000000+1)::text;
	
	n1 = substring(ie_ce from 1 for 1)::integer;
	n2 = substring(ie_ce from 2 for 1)::integer;
	n3 = substring(ie_ce from 3 for 1)::integer;
	n4 = substring(ie_ce from 4 for 1)::integer;
	n5 = substring(ie_ce from 5 for 1)::integer;
	n6 = substring(ie_ce from 6 for 1)::integer;
	n7 = substring(ie_ce from 7 for 1)::integer;
	n8 = substring(ie_ce from 8 for 1)::integer;
	n9 = substring(ie_ce from 9 for 1)::integer;
	
	s = 9*n1 + 8*n2 + 7*n3 + 6*n4 + 5*n5 + 4*n6 + 3*n7 + 2*n8;
	m = s%11;
	dv = 11 - m;
	-- raise exception 'm vale(%), dv vale(%), n6(%)',m,dv, n6; 	
	if (dv = n9) then
		d = TRUE;
		return ie_ce;
		exit;
	else
		d = FALSE;
		continue;
	end if;
	if (d = TRUE) then exit; end if;
	end loop;
return 0;	
end;
$$
language 'plpgsql';	

-- testar com select ie_ce_gerador()

-- Criação de domínios para melhorar as restrições dos tipos e agilizar criação de novas tabelas

CREATE DOMAIN dom_cnpj AS text
    CONSTRAINT chk_cnpj CHECK (f_cnpjcpf(0, VALUE) = 1) NOT NULL;

CREATE DOMAIN dom_cpf AS text
    CONSTRAINT chk_cpf CHECK (f_cnpjcpf(1, VALUE)=1 OR (f_cnpjcpf(2, VALUE)=1 AND VALUE ~ '^informal$')) NOT NULL; 
	-- Aceitar 'informal' ou 11 dígitos do CPF

CREATE DOMAIN dom_ie_ce AS text -- inscrição estadual para o Ceará, pois muda de um estado para outro
    CONSTRAINT chk_ie_ce CHECK (VALUE ~ '^isento$|^[0-9]{9}$') NOT NULL;

CREATE DOMAIN dom_cep AS text
    CONSTRAINT chk_cep CHECK (VALUE ~ '^[0-9]{8}$') NOT NULL;

	-- Os abaixo devem permitir nulo

CREATE DOMAIN dom_email AS text
	CONSTRAINT chk_email CHECK (VALUE ~ '^[a-zA-Z][[:alnum:]_.-]*@[a-zA-Z][[:alnum:]_.-]*[.][a-zA-Z]+$');

CREATE DOMAIN dom_url AS text
	CONSTRAINT chk_url CHECK (VALUE ~ '^((https|http):\/\/)?(([a-z]([a-z0-9\-_]*\.)+)(aero|arpa|biz|com|coop|edu|gov|info|int|jobs|mil|museum|name|nato|net|org|pro|travel|br|[a-z]{2})(\/[a-z0-9_\-\.~]+)*(\/([a-z0-9_\-\.]*)(\?[a-z0-9+_\-\.\/%=&]*)?)?)$');

CREATE DOMAIN dom_telefone AS text
	CONSTRAINT chk_telefone CHECK (VALUE ~ '^[3-9]{1}[0-9]{7}$'); -- Válidos somente iniciados com 3 e superiores

create table tipos
(
	tipo int primary key,
	descricao varchar(50) not null
);


-- Tabelas
create table logradouros
(
	logradouro int primary key,
	descricao varchar(50) not null
);

create table bairros
(
	bairro int primary key,
	descricao varchar(50) not null
);

create table ufs
(
	uf int primary key,
	descricao varchar(2) not null
);

create table municipios
(
	municipio varchar(50) primary key,
	uf int not null,
	constraint uf_fk foreign key (uf) references ufs(uf)
);

create table ceps
(
	cep dom_cep,
	tipo int, 
	logradouro int,
	bairro int,
	municipio int,
	primary key(cep, logradouro), 
	constraint tipo_fk foreign key (tipo) references tipos(tipo),
	constraint logradouro_fk foreign key (logradouro) references logradouros(logradouro),
	constraint bairro_fk foreign key (bairro) references bairros(bairro),
	constraint municipio_fk foreign key (municipio) references municipios(municipio)
);

create table enderecos
(
	cep int not null,
	logradouro int not null,
	numero varchar(8) not null,
	primary key(cep, numero),
	constraint cep_fk foreign key (cep,logradouro) references ceps(cep,logradouro)
);

-- Lembrando que aqui ainda faltam alguns atributos para o endereço: bloco, andar, apartamento e talvez ainda outros

create table telefones
(
	telefone int not null primary key,
	ddd varchar(4) not null,
	numero dom_telefone
);

create table fisicas
(
	fisica int primary key,
	cpf dom_cpf
);

create table juridicas
(
	cnpj dom_cnpj primary key,
	inscricao_estadual dom_ie_ce,
	site dom_url
);

create table pessoas
(
	pessoa int not null primary key,	
	nome varchar(45) not null,
	cep int not null,
	tipo int not null,
	numero varchar(8) null,
	telefone int, -- Permitindo NULL, para o caso de alguém não ter telefone
	email dom_email,
	constraint telefone_fk foreign key (telefone) references telefones(telefone),
	constraint endereco_fk foreign key (cep,numero) references enderecos(cep,numero),
	constraint fisica_fk foreign key(tipo) references fisicas(fisica),
	constraint juridica_fk foreign key(tipo) references juridicas(cnpj)
);

-- Criação de índices parciais, que permitirão a criação de campos com CPF únicos, mas somente para os que existirem

create unique index idx_cpf on fisicas (cpf)
    WHERE NOT (cpf = 'informal');

create unique index idx_ie on juridicas (inscricao_estadual)
    WHERE NOT (inscricao_estadual = 'isento');

-- INSERINDO ALGUNS REGISTROS PARA TESTE

insert into fisicas values(1, '22366437803');
insert into fisicas values(2, '47720595203');
insert into fisicas values(3, '33557245640');
insert into fisicas values(4, '56484636427');
insert into fisicas values(5, '56484636426'); -- inválido
insert into fisicas values(6, 'informal');
insert into fisicas values(7, '90807363685')
insert into fisicas values(8, 'informal_erro');
insert into fisicas values(8, 'informal'); -- aceita repetir informal
insert into fisicas values(9, 'informal');
insert into fisicas values(10, 'informal');



/*
Observações úteis sobre esta modelagem:

Até o últmo banco de dados que criei, o cadastro de pessoas era geralmente algo como:

pessoa(codigo, nome, rua, numero, bairro, cidade, uf, cep)

Ou seja, desnormalizado, quese todos os campos permitindo valores duplicados. 

Para min foi muito proveitosa a discussão na lista de postgresql, como também algumas leituras sobre o assunto, que 
me fizeram perceber a grande importância do assunto.

Inclusive comparando este modelo com os dois anteriores (controle de estoque e vídeo locadoras), a diferença é grande:

- O CPF permitia nulos no controle de estoque
- Agora ele tem um domínio que valida seus dados e um índice parcial que permite a entrada "informal" e entradas válidas 
para CPF (sendo que para estas últimas é aplicado o índice único).

- As tabelas clientes, fornecedores e ceps foram normalizadas e agora é pessoas, ceps e as auxiliares (normalizadas).


As três Primeiras Formas Normais (aplicadas neste modelo):

1FN - todos os atributos possuem valores simples (nenhum é composto)
2FN - deve estari na 1FN e não possuir dependência funcional parcial (todos os atributos dependem integralmente da chave primária)
2FN - deve estar na 2FN e não possuir nenhuma dependência funcional transitiva (nenhum atributo pode depender de outro atributo que não seja PK)
Quando existem dependências cíclicas ou multivaloradas devemos aplicar a 4FN e a 5FN.


Após a divulgação do modelo controle de estoque, tivemos um longo debate na lista de PostgreSQL, o que melhorou meus 
conhecimentos sobre o modelo relacional, modelagem, normalização e cia.

Agora trago mais um modelo, mais simples mas acredito que mais coerente e mais robusto, mas mesmo assim acredito que tenha itens a melhorar. 

Algo importante é a implementação de chaves naturais. Veja que as relações pessoas, municipios, ceps, enderecos e
juridicas estão com vhaves naturais, mas o mais importante aqui é a idéia, o conceito, que devemos ter na chave primária, 
campo(s) que sejam realmente representativos da relação. Fechando, a chave deve impedir totalmente duplicações.
Só para exemplificar, veja as duas tabelas abaixo:

create table juridicas
(
	cnpj dom_cnpj primary key,
	inscricao_estadual dom_ie_ce,
	site dom_url
);

create table juridicas2
(
	juridica int primary key,
	cnpj dom_cnpj,
	inscricao_estadual dom_ie_ce,
	site dom_url
);

Na tabela juridicas2, podemos inserir registros com nomes duplicados com grande facilidade, já que não existe nenhum controle sobre isso pelo SGBD.
Para o SGBD apenas será fiscalizado se o campo juridica (um ID) não será duplicado.
Já na tabela juridicas é praticamente impossível duplicar um registro, pois a chave é um CNPJ, o SGBD não deixa duplicar.

No modelo original (do Ary Júnior) o endereço guarda pessoa, assim como o telefone também guarda pessoa.

Então fui refletir um pouco e encontrei pelo menos um bom motivo para fazer diferente, adicionar o
endereço em pessoas:

Sabemos que existem mais pessoas que endereços.
Para cada nova pessoa cadastrada teremos que cadastrar também um novo endereço. E o mais grave é que, em sendo pessoas físicas,
haverá duplicação de endereços para as pessoas de um mesmo endereço.

Colaboracão de Ribamar FS (http://pg.ribafs.net.
Artigo fonte de inspiração: Estudo de Caso de Projeto de Bancos de Dados para Contas a Pagar e Receber, 
de Ary Júnior na SQL Magazine 52.


Informações Fiscais Úteis:

Consulta de CNPJ online - http://www.receita.fazenda.gov.br/PessoaJuridica/CNPJ/cnpjreva/Cnpjreva_Solicitacao.asp

CNPJ - é único (até as filiais também têm o seu). Órgãos públicos são assim, a sede administrativa tem um CNPJ e suas unidades têm um CNPJ
semelhante

IE (Inscrição Estadual) - único, sem nulo, mas quando não existir informar ISENTO (recomendação do SINTEGRA). A formação é própria de cada estado.

IM (Inscrição Municipal) - único, mas é exigido somente para empresas de prestação de serviço e outros específicos.

Sugestão: para todos os três acima impedir nulo e quando não existir, usar ISENTO, mas o índice nulo deverá então ser um índice funcional, evitando 
ISENTO.

A máscara do CNPJ é 99.999.999/9999-99. O número do CNPJ mesmo são os 8 digitos antes da barra e os 4 digitos seguintes a barra são o numero da empresa e os 2 ultimos são digitos verificadores.
Logo em caso de matriz e filiais os 8 primeiros são iguais já que são da mesma empresa e os 4 digitos seguintes são 0001 para matriz e a sequência são filiais.

Empresas com filiais, usam o mesmo CNPJ, com a diferença de os 4 dígitos finais:
Se a matriz for 00.000.000/0001-00 
A filia será 00.000.000/0002-00

SINTEGRA (IE) - http://www.sintegra.gov.br/
Exemplo: Ceará - http://www.sefaz.ce.gov.br/Sintegra/Sintegra.Asp?estado=CE (Consulta do CNPJ e da IE. Consulte sem máscara)

Exemplos:
00043711000143 - DNOCS - Fortaleza
00043711001115 - DNOCS - Montes Claros

Busca de CEP:
http://www.correios.com.br/servicos/cep/cep_default.cfm
*/

/*
-- Domínios
-- SELECT * FROM information_schema.domains WHERE domain_schema='public';

Domínios

Um domínio se baseia em um determinado tipo base e, para muitas finalidades, é intercambiável com o seu tipo base. Entretanto, o domínio pode ter restrições limitando os valores válidos a um subconjunto dos valores permitidos pelo tipo base subjacente.

Se a coluna for baseada em um domínio, esta coluna se refere ao tipo subjacente do domínio (e o domínio é identificado em domain_name e nas colunas associadas).

CREATE DOMAIN nome [AS] tipo_de_dado
    [ DEFAULT expressão ]
    [ restrição [ ... ] ]

onde restrição é:

[ CONSTRAINT nome_da_restrição ]
{ NOT NULL | NULL | CHECK (expressão) }

O comando CREATE DOMAIN cria um domínio. O domínio é, essencialmente, um tipo de dado com restrições opcionais (restrições no conjunto de valores permitidos). O usuário que cria o domínio se torna o seu dono.

Se for fornecido o nome do esquema (por exemplo, CREATE DOMAIN meu_esquema.meu_dominio ...), então o domínio será criado no esquema especificado, senão será criado no esquema corrente. O nome do domínio deve ser único entre os tipos e domínios existentes no esquema do domínio.

Domínios são úteis para reunir restrições comuns em campos em um único local para manutenção. Por exemplo, várias tabelas podem conter colunas de endereço de correio eletrônico, todas requerendo a mesma restrição de verificação (CHECK). Em vez de definir as restrições em cada tabela individualmente, pode ser definido um domínio.

Exemplo:
CREATE DOMAIN dom_cep AS text
    CONSTRAINT chk_cep CHECK (VALUE ~ '^\\d{8}$') NOT NULL;

-- Função para aplicar a máscara na exibição
CREATE FUNCTION formata_cep(cep dom_cep) RETURNS TEXT AS $$
BEGIN
    RETURN substr(cep,1,5) || '-' || substr(cep,6,3);
END;
$$ LANGUAGE plpgsql;

*/

/*
Expressões regulares:

Página oficial: http://pgdocptbr.sourceforge.net/pg80/functions-matching.html
Testador online para expressões POSIX:
http://www.spaweditor.com/scripts/regex/index.php

Data (Formato dd/mm/aaaa) -	^([0-9]|[0,1,2][0-9]|3[0,1])/([\d]|1[0,1,2])/\d{4}$
Data (Formato aaaa-mm-dd) -	^\d{4}-(0[0-9]|1[0,1,2])-([0,1,2][0-9]|3[0,1])$
Hora (HH:MM) -	^([0-1][0-9]|[2][0-3])(:([0-5][0-9])){1,2}$

Nome completo - ^[a-zA-Z][a-zA-Z][a-zA-Z]* [a-zA-Z ]*$
Numero Decimal -	^\d*[0-9](\.\d*[0-9])?$

Arquivos	- ^[a-zA-Z0-9-_\.]+\.(pdf|txt|doc|csv)$
Codigo Cor HTML -	^#?([a-f]|[A-F]|[0-9]){3}(([a-f]|[A-F]|[0-9]){3})?$	(exemplo: #00ccff
Imagem	- ^[a-zA-Z0-9-_\.]+\.(jpg|gif|png)$
IP	- ^((25[0-5]|2[0-4][0-9]|1[0-9]{2}|[0-9]{1,2})\.){3}(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[0-9]{1,2})$
Arquivos Multimedia -	^[a-zA-Z0-9-_\.]+\.(swf|mov|wma|mpg|mp3|wav)$	(Exemplo: company-presentation.swf)

CNPJ (com máscara) - ^[0-9]{2}.[0-9]{3}.[0-9]{3}/[0-9]{4}-[0-9]{2}$ (Exemplo: 00.043.711/0001-43)
CNPJ (sem máscara) - ^[0-9]{2}[0-9]{3}[0-9]{3}[0-9]{4}[0-9]{2}$ (Exemplo: 00043711000143)
CPF (com máscara) - ^[0-9]{3}.[0-9]{3}.[0-9]{3}-[0-9]{2} (Exemplo: 123.456.789-22)
CPF (sem máscara) - ^[0-9]{3}[0-9]{3}[0-9]{3}[0-9]{2} (Exemplo: 12345678922)
Inscrição Estadual (SP, com máscara) - 	^[0-9]{3}.[0-9]{3}.[0-9]{3}.[0-9]{3} (Exemplo: 110.042.490.114)
Inscrição Estadual (SP, com máscara) - 	^[0-9]{3}[0-9]{3}[0-9]{3}[0-9]{3} (Exemplo: 110042490114)
	Exemplo Ceará: ^[0-9]{3}[0-9]{3}[0-9]{3} (Exemplo: 060000015 )
	Exemplo Ceará: ^[0-9]{2}.[0-9]{6}-[0-9]{1} (Exemplo: 06.000001-5 )

Gerador/Validador de CNPJ e CPF online:
http://www.uesval.com.br/informatica/gerador_cpfcnpj.html

Telefone (Brasil com DDD) - ^\([0-9]\d{2}\)-\d{4}-\d{4}$	(085)-3423-4542
Telefone (Brasil sem DDD) - ^\d{4}-\d{4}$  (2634-3454)
Telefone (US) - ^[2-9]\d{2}-\d{3}-\d{4}$	250-555-4542
Telefone Internacional	^(([0-9]{1})*[- .(]*([0-9a-zA-Z]{3})*[- .)]*[0-9a-zA-Z]{3}[- .]*[0-9a-zA-Z]{4})+$	(Exemplo: 1.245.532.3422)

Codigo Postal (Brasil, sem máscara) - ^[[:digit:]]{8}$	60420440
Codigo Postal (Brasil, com máscara)	^[0-9]{5}-[0-9]{3}$	60420-440
Codigo Postal (EUA)	^([A-Z][0-9]){3}$	V2B2S3	Testar

uf CHAR(2)          -- unidade da federação
 CONSTRAINT chk_uf
    CHECK (uf ~ '^A(C|L|M|P)|BA|CE|DF|ES|GO|M(A|G|S|T)|P(A|B|E|I|R)|R(J|N|O|R|S)|S(C|E|P)|TO$')

E-mail	- ^[a-zA-Z][\\w.-]*@[a-zA-Z][\\w.-]*[.][a-zA-Z]+$

URL	- ^(http[s]?://|ftp://)?(www\.)?[a-zA-Z0-9-\.]+\.(com|org|net|mil|edu|ca|co.uk|com.au|gov|br)$

*/

