<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head>


  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <style type="text/css">
 dl.teste
{
width: 41.1em;
margin: 2em 0;
padding: 0;
font-family: georgia, times, serif;
}

  .prop {
    height:50px;
    float:right;
    width:1px;
  }

.teste dt
{
width: 15em;
float: left;
margin: 0 0 0 0;
padding: .5em;
border-top: 1px solid #999;
font-weight: bold;
min-height:80px;
}

/* commented backslash hack for mac-ie5 \*/
dt { clear: both; }
/* end hack */

.teste dd
{
float: left;
width: 24em;
margin: 0 0 0 0;
padding: .5em;
min-height:80px;
border-top: 1px solid #999;
text-align: justify;
}

#notas{
  clear:both;
}
  </style><!--[if IE]>
<style>
.teste dd {
	height:100px;
}

</style>
<![endif]--><!--[if IE 5.0]>
<style>
.teste dd {
	height:100px;
}

</style>
<![endif]--><title>Explain - Pgadmin 3</title></head><body>
<script type="text/javascript"><!--
google_ad_client = "pub-2659094670102710";
google_ad_width = 728;
google_ad_height = 90;
google_ad_format = "728x90_as";
google_ad_type = "text_image";
google_ad_channel ="";
google_color_border = "FEFEFE";
google_color_link = "0000FF";
google_color_bg = "FEFEFE";
google_color_text = "000000";
google_color_url = "008000";
//--></script>
<script type="text/javascript" src="explain_arquivos/show_ads.js">
</script><iframe name="google_ads_frame" src="explain_arquivos/ads.html" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" frameborder="0" height="90" scrolling="no" width="728"></iframe>
<dl class="teste">
<dt>Index scan: <img src="explain_arquivos/ex_index_scan.png"></dt>
<dd>Foi feito uma varredura no índice da tabela</dd>

<dt>Table scan: <img src="explain_arquivos/ex_scan.png" alt="Table Scan"></dt>
<dd>Foi feito um table scan na tabela</dd>

<dt>Aggregate(ou Hash Aggregate): <img src="explain_arquivos/ex_aggregate.png" alt="Aggregate(ou Hash Aggregate)"></dt>
<dd>Indica uma função agregada. (COUNT SUM MIN MAX AVG STDDEV VARIANCE)</dd>

<dt>Append: <img src="explain_arquivos/ex_append.png"></dt>
<dd>Disparado por UNIONS e por herança. Seu custo é simplesmente a soma de todas as entradas.</dd>

<dt>Bitmap Heap Scan: <img src="explain_arquivos/ex_bmp_heap.png"></dt>
<dd>É usado um bitmap (mapa de bits). Usado em colunas de baixa cardinalidade.</dd>

<dt>Bitmap Index Scan: <img src="explain_arquivos/ex_bmp_index.png"></dt>
<dd>É usado um bitmap (mapa de bits) a partir do índice. Usado em colunas de baixa cardinalidade.</dd>

<dt>Agrupamento: <img src="explain_arquivos/ex_group.png"></dt>
<dd>Usado na cláusula group by</dd>

<dt>Hash: <img src="explain_arquivos/ex_hash.png"></dt>
<dd>Denota uma função hash executada na tabela (para ser usada posteriormente em um hash join ou hash left join)</dd>

<dt>Hash join (ou Hash Left Join):<sup>2</sup> <img src="explain_arquivos/ex_join.png" alt="Hash (Left) Join"></dt>
<dd></dd>

<dt>Limit: <img src="explain_arquivos/ex_limit.png"></dt>
<dd>Cláusula de limitação</dd>

<dt>Materialize: <img src="explain_arquivos/ex_materialize.png"></dt>
<dd>É usado com sub-selects e merge-joins. O resultado é colocado numa tabela temporária.</dd>

<dt>Merge Join: <img src="explain_arquivos/ex_merge.png" alt="Merge Join"></dt>
<dd>O<sup>3</sup> Merge Join é um operador binário.Os lados esquerdo e direito são os fluxo de dados externo e interno, respectivamente.
Ambos fluxos devem ser organizados de acordo com a chave do merge-join.
Primeiro, uma linha do fluxo exterior é lido. Isso inicializa os valores das chaves do merge join.
Então, linhas do fluxo interno são lidas até que uma linha tenha uma valor que case ou seja maior
(exceto se a coluna chave é decendente ) seja encontrada. 
Se as chaves da junção casam, então a columa qualificadora é passada adiante para processamento adicional, 
e uma próxima chamada ao operador merge-join continua lendo do fluxo de dados atual.
Se os novos valores são maiores que a chave de comparação, então esses valores são usados 
como a chave de junção, enquanto a traz linhas dos outros fluxos de dados.
Esse processo continua até um dos fluxo de dados exaurir.
</dd>

<dt>Nested Loop (ou Nested Loop Left Join): <img src="explain_arquivos/ex_nested.png" alt="Nested Loop"></dt>
<dd>Loop Aninhado<sup>1</sup>: A relação à direita é escaneada uma vez para cada linha encontrada na relação à esquerda.
Essa estratégia é fácil de implementar, mas pode ser uma grande consumidora de tempo. 
(Porém, se a relação direita pode ser varrida usando um índicescan, essa pode ser uma boa estratégia. 
É possível usar valores da linha atual da relação esquerda como chaves para a varredura de índice da relação direita.)</dd>

<dt>Function: <img src="explain_arquivos/ex_result.png"></dt>
<dd>Resultado de uma função</dd>

<dt>: <img src="explain_arquivos/ex_seek.png"></dt>
<dd>Explicação</dd>

<dt>SetOp Intersect, SetOp Intersect All, SetOp Except, SetOp Except All : <img src="explain_arquivos/ex_setop.png"></dt>
<dd>Encontra grupos de linhas duplicadas. Usado para INTERSECT, INTERSECT ALL, EXCEPT, EXCEPT ALL.</dd>

<dt>Sort: <img src="explain_arquivos/ex_sort.png"></dt>
<dd>Ordenação</dd>

<dt>Subquery: <img src="explain_arquivos/ex_subplan.png"></dt>
<dd>Usado com UNIONS</dd>

<dt>Varredura TID: <img src="explain_arquivos/ex_tid_scan.png"></dt>
<dd>Id da coluna da tupla. É usado apenas quando o cláusula "ctid =" aparece na sua query. Muito raro, e muito rápido.
</dd>

<dt>Unique: <img src="explain_arquivos/ex_unique.png"></dt>
<dd>Usado quando queremos obter dados únicos da tabela (por exemplo, com DISTINCT)</dd>

<dt>Desconhecido: <img src="explain_arquivos/ex_unknown.png"></dt>
<dd>Desconhecido</dd>



</dl>
<div id="notas">
<ol>
<li>Retirado da documentação do PostgreSQL</li>
<li>Adaptado de <a href="http://en.wikipedia.org/wiki/Hash_Join">http://en.wikipedia.org/wiki/Hash_Join</a></li>
<li>Adapatado de <a href="http://infocenter.sybase.com/help/index.jsp?topic=/com.sybase.help.ase_15.0.query_proc/html/query_proc/query_proc82.htm">http://infocenter.sybase.com/help/index.jsp?topic=/com.sybase.help.ase_15.0.query_proc/html/query_proc/query_proc82.htm</a></li>
</ol>
<ul>
<li>Há nesse artigo uma nota interessante em relação a indíces bitmap: <a href="http://mportes.blogspot.com/2005/05/ndices-falando-livremente.html">http://mportes.blogspot.com/2005/05/ndices-falando-livremente.html</a></li>
</ul>
<p>Segundo li em alguns sites ( <a href="http://mportes.blogspot.com/2005/05/ndices-falando-livremente.html">http://mportes.blogspot.com/2005/05/ndices-falando-livremente.html</a> )e documentos, o índice do tipo bitmap é bom para colunas de baixa cardinalidade</p>
<p>Há uma explicação do merge join na wikipedia em: <a href="http://en.wikipedia.org/wiki/Sort-merge_join">http://en.wikipedia.org/wiki/Sort-merge_join</a></p>
<p><a href="http://www.adp-gmbh.ch/ora/sql/join/join_methods.html">Merge Joins (Oracle)</a></p>
<p>Algumas explicações foram retiradas de <a href="http://www.gtsm.com/oscon2003/ops.html">http://www.gtsm.com/oscon2003/ops.html</a></p>
</div>
</body></html>