<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Set Returning Functions</title><meta content="text/html; charset=windows-1252" http-equiv=Content-Type><meta name="keywords" content="postgresql, PostgreSQL, postgres, Non-FAQ, Documentation, Solaris, Linux, SQL, database, bugs, articles, fixes, source code"></head>

<body alink="#ff0000" bgcolor="#6884A4" link="#000066" text="#000000" vlink="#000099"><table border="0" cellpadding="0" cellspacing="0" align="center"><tr valign="top"><td width="100%"><div align="center"><img alt="PostgreSQL" height="129" src="/images/header3.gif" width="576"></div></td></tr>

<tr><td align="center">
<table width="573" border="0" cellspacing="0" cellpadding="0" bgcolor="#10006B"><tr valign="middle"><td>
<table width="100%" border="0" cellspacing="1" cellpadding="0"><tr valign="middle">
<td align="center" bgcolor="#10006B"><a href="/guides" title="PostgreSQL Guides Home" accesskey="g"><font size="-1" color="#FFFFFF">PostgreSQL Guides Home</font></a></td>
<td align="center" bgcolor="#10006B"><a href="/guides/DocList" title="Document List" accesskey="l"><font size="-1" color="#FFFFFF">Document List</font></a></td>
<td align="center" bgcolor="#10006B"><a href="/guides/UserOptions" title="User Options" accesskey="o"><font size="-1" color="#FFFFFF">UserOptions</font></a></td>
<td align="center" bgcolor="#10006B"><a href="/guides/HelpPage" title="Help" accesskey="h"><font size="-1" color="#FFFFFF">Help</font></a></td>
</tr><tr>
<td align="center" bgcolor="#10006B"><a href="http://techdocs.postgresql.org/guides/SetReturningFunctions/subscribeform" title="Subscribe" accesskey="s"><font size="-1" color="#FFFFFF">Subscribe</font></a></td>
<td align="center" bgcolor="#10006B"><a href="/guides/RecentChanges" title="Recent Changes (last edited 2 hours ago)" accesskey="c"><font size="-1" color="#FFFFFF">Recent Changes</font></a></td>
<td align="center" bgcolor="#10006B">
 <a href="http://techdocs.postgresql.org/guides/SetReturningFunctions/editform" title="Edit this page (last edited 2 hours ago)" accesskey="e"><font size="-1" color="#FFFFFF">Edit this page</font></a>
</td>
<td align="center" bgcolor="#10006B"><a href="http://techdocs.postgresql.org/guides/SetReturningFunctions/diff" title="Page History (last edited 2 hours ago)" accesskey="h"><font size="-1" color="#FFFFFF">Page History</font></a></td>
</tr></table></td></tr></table>
</td></tr>

<tr valign="top"><td><table border="0" cellpadding="0" cellspacing="0"><tr valign="top"><td width="132"><table border="0" cellspacing="0" cellpadding="0" width="138"><tr><td align="left"><br><table border="0" cellspacing="0" cellpadding="0" bgcolor="000000" width="132"><tr><td><table border="0" cellspacing="1" cellpadding="3" width="100%"><tr><th bgcolor="#CDDDEB" width="50%"><u><font size="-1"><a href="/accounts/login.php" target="_self">Login</a></font></u></th><th bgcolor="#CDDDEB" width="50%"><u><font size="-1"><a href="/accounts/register.php" target="_self">Register</a></font></u></th></tr></table></td></tr></table><br><table border="0" cellspacing="0" cellpadding="0" bgcolor="000000" width="132"><tr><td><table border="0" cellspacing="1" cellpadding="3" width="100%"><tr><th colspan="1" bgcolor="#CDDDEB" width="120"> <a href="/redir.php?link=/" target="_self"><font size="-1">Home</font></a></th></tr></table></td></tr></table><br><table border="0" cellspacing="0" cellpadding="0" bgcolor="000000" width="132"><tr><td><table border="0" cellspacing="1" cellpadding="3" width="100%"><tr><th colspan="1" bgcolor="#CDDDEB" width="120"> <a href="/redir.php?link=http://www.ca.postgresql.org/index.html" target="_blank"><font size="-1">PostgreSQL Home</font></a></th></tr></table></td></tr></table><br><table border="0" cellspacing="0" cellpadding="0" bgcolor="000000" width="132"><tr><td><table border="0" cellspacing="1" cellpadding="3" width="100%"><tr><th colspan="1" bgcolor="#CDDDEB" width="120"> <a href="/redir.php?link=http://advocacy.postgresql.org" target="_blank"><font size="-1">Advocacy & Marketing</font></a></th></tr></table></td></tr></table><br><table border="0" cellspacing="0" cellpadding="0" bgcolor="000000" width="132"><tr><td><table border="0" cellspacing="1" cellpadding="3" width="100%"><tr><th colspan="1" bgcolor="#CDDDEB" width="120"> <a href="/redir.php?link=http://advocacy.postgresql.org/download/" target="_blank"><font size="-1">Software</font></a></th></tr></table></td></tr></table><br><table border="0" cellspacing="0" cellpadding="0" bgcolor="000000" width="132"><tr><td><table border="0" cellspacing="1" cellpadding="3" width="100%"><tr><th colspan="1" bgcolor="#CDDDEB" width="120"> <a href="http://groups.google.com/groups?hl=en&group=comp.databases.postgresql" target="_blank"><font size="-1">Search</font></a></th></tr></table></td></tr></table><br><table border="0" cellspacing="0" cellpadding="0" bgcolor="000000" width="132"><tr><td><table border="0" cellspacing="1" cellpadding="3" width="100%"><tr><th colspan="1" bgcolor="#CDDDEB" width="120"> <font size="-1" color="#000099">Online Books</font></th></tr><tr><td bgcolor="FFFFFF" align="center"> <a href="/redir.php?link=http://www.postgresql.org/docs/awbook.html" target="_blank"><font size="-1">Book : PostgreSQL Intro and Concepts</font></a></td></tr><tr><td bgcolor="FFFFFF" align="center"> <a href="/redir.php?link=http://www.postgresql.info" target="_blank"><font size="-1">Book : Practical PostreSQL</font></a></td></tr></table></td></tr></table><br><table border="0" cellspacing="0" cellpadding="0" bgcolor="000000" width="132"><tr><td><table border="0" cellspacing="1" cellpadding="3" width="100%"><tr><th colspan="1" bgcolor="#CDDDEB" width="120"> <a href="/redir.php?link=http://www.postgresql.org/users-lounge/index.html" target="_blank"><font size="-1">Users' Lounge</font></a></th></tr><tr><td bgcolor="FFFFFF" align="center"> <a href="/redir.php?link=http://www.postgresql.org/users-lounge/docs/faq.html" target="_blank"><font size="-1">User FAQs'</font></a></td></tr><tr><td bgcolor="FFFFFF" align="center"> <a href="/redir.php?link=http://www.postgresql.org/users-lounge/docs/" target="_blank"><font size="-1">Released Docs'</font></a></td></tr><tr> <td bgcolor="FFFFFF" align="center"> <a href="/redir.php?link=http://www.postgresql.org/idocs" target="_blank"><font size="-1">Searchable Docs'</font></a></td></tr></table></td></tr></table><br><table border="0" cellspacing="0" cellpadding="0" bgcolor="000000" width="132"><tr><td><table border="0" cellspacing="1" cellpadding="3" width="100%"><tr><th colspan="1" bgcolor="#CDDDEB" width="120"> <a href="/redir.php?link=http://developer.postgresql.org/index.php" target="_blank"><font size="-1">Developers' Corner</font></a></th></tr><tr><td bgcolor="FFFFFF" align="center"> <a href="/redir.php?link=http://developer.postgresql.org/cvsweb.cgi/pgsql-server/" target="_blank"><font size="-1">Developer CVSWeb</font></a></td></tr><tr><td bgcolor="FFFFFF" align="center"> <a href="/redir.php?link=http://candle.pha.pa.us/main/writings/pgsql/sgml" target="_blank"><font size="-1">Developer Docs'</font></a></td></tr><tr><td bgcolor="FFFFFF" align="center"> <a href="/redir.php?link=http://developer.postgresql.org/readtext.php?FAQ_DEV%2BDevelopers-FAQ" target="_blank"><font size="-1">Developer FAQ</font></a></td></tr></table></td></tr></table><br><table border="0" cellspacing="0" cellpadding="0" bgcolor="000000" width="132"><tr><td><table border="0" cellspacing="1" cellpadding="3" width="100%"><tr><th colspan="1" bgcolor="#CDDDEB" width="120"> <a href="/redir.php?link=http://www.postgresql.org/users-lounge/commercial-support.html" target="_blank"><font size="-1">Commercial Support</font></a></th></tr></table></td></tr></table><br><table border="0" cellspacing="0" cellpadding="0" bgcolor="000000" width="132"><tr><td><table border="0" cellspacing="1" cellpadding="3" width="100%"><tr><th colspan="1" bgcolor="#CDDDEB" width="120"><a href="/redir.php?link=http://gborg.postgresql.org" target="_blank"><font size="-1">GBorg Project Site</font></a></th></tr></table></td></tr></table><br><table border="0" cellspacing="0" cellpadding="0" bgcolor="000000" width="132"><tr><td><table border="0" cellspacing="1" cellpadding="3" width="100%"><tr><th colspan="1" bgcolor="#CDDDEB" width="120"> <a href="/redir.php?link=http://jdbc.postgresql.org" target="_blank"><font size="-1">JDBC</font></a></th></tr><tr><td colspan="1" bgcolor="#FFFFFF" width="120" align="center"><a href="/redir.php?link=http://lab.applinet.nl/postgresql-jdbc/" target="_blank"><font size="-1">Conformance</font></a></td></tr><tr><td colspan="1" bgcolor="#FFFFFF" width="120" align="center"> <a href="/redir.php?link=http://jdbc.fastcrypt.com" target="_blank"><font size="-1">JAR Files</font></a></td></tr><tr><td colspan="1" bgcolor="#FFFFFF" width="120" align="center"><a href="/redir.php?link=http://jdbc.postgresql.org/doc.html" target="_blank"><font size="-1">JDBC Docs'</font></a></td></tr><tr><td colspan="1" bgcolor="#FFFFFF" width="120" align="center"><a href="/redir.php?link=http://www.fankhausers.com/postgresql/jdbc/" target="_blank"><font size="-1">JDBC FAQ</font></a></td></tr></table></td></tr></table><br><table border="0" cellspacing="0" cellpadding="0" bgcolor="000000" width="132"><tr><td><table border="0" cellspacing="1" cellpadding="3" width="100%"><tr><th colspan="1" bgcolor="#CDDDEB" width="120"> <a href="/redir.php?link=http://odbc.postgresql.org" target="_blank"><font size="-1">ODBC</font></a></th></tr></table></td></tr></table><br><table border="0" cellspacing="0" cellpadding="0" bgcolor="000000" width="132"><tr><td><table border="0" cellspacing="1" cellpadding="3" width="100%"><tr><th colspan="1" bgcolor="#CDDDEB" width="120"> <a href="/redir.php?link=http://www.brasileiro.net/postgres/cookbook/" target="_blank"><font size="-1">PL/pgSQL CookBook</font></a></th></tr></table></td></tr></table><br><table border="0" cellspacing="0" cellpadding="0" bgcolor="000000" width="132"><tr><td><table border="0" cellspacing="1" cellpadding="3" width="100%"><tr><th colspan="1" bgcolor="#CDDDEB" width="120"> <a href="/redir.php?link=http://techdocs.postgresql.org" target="_self"><font size="-1">TechDocs</font></a></th></tr><tr><td colspan="1" bgcolor="#FFFFFF" width="120" align="center"> <a href="/redir.php?link=/techdocs/bookreviews.php" target="_self"><font size="-1">Book Reviews</font></a></td></tr><td colspan="1" bgcolor="#FFFFFF" width="120" align="center"> <a href="/redir.php?link=/bugsfixes.php" target="_self"><font size="-1">Bugs & Fixes</font></a></td></tr><tr><td colspan="1" bgcolor="#FFFFFF" width="120" align="center"> <a href="/redir.php?link=/college/index.php" target="_self"><font size="-1">College</font></a></td></tr><tr><td colspan="1" bgcolor="#FFFFFF" width="120" align="center"> <a href="/redir.php?link=/companies.php" target="_self"><font size="-1">Consultants</font></a></td></tr><tr><td colspan="1" bgcolor="#FFFFFF" width="120" align="center"> <a href="/redir.php?link=/contributors.php" target="_self"><font size="-1">Contributors</font></a></td></tr><tr><td colspan="1" bgcolor="#FFFFFF" width="120" align="center"> <a href="/redir.php?link=/errors.php" target="_self"><font size="-1">Errors</font></a></td></tr><tr><td colspan="1" bgcolor="#FFFFFF" width="120" align="center"><a href="/redir.php?link=/source.php" target="_self"><font size="-1">Extra Functions</font></a></td></tr><tr><td colspan="1" bgcolor="#FFFFFF" width="120" align="center"><a href="/redir.php?link=/hosting.php" target="_self"><font size="-1">Hosting</font></a></td></tr><tr><td colspan="1" bgcolor="#FFFFFF" width="120" align="center"> <a href="/redir.php?link=/installguides.php" target="_self"><font size="-1">Installation Guides</font></a></td></tr><tr><td colspan="1" bgcolor="#FFFFFF" width="120" align="center"> <a href="/redir.php?link=/oresources.php" target="_self"><font size="-1">Other Resources</font></a></td></tr><tr><td colspan="1" bgcolor="#FFFFFF" width="120" align="center"> <a href="/redir.php?link=/oresources.php#reviews" target="_self"><font size="-1">Reviews</font></a></td></tr><tr><td colspan="1" bgcolor="#FFFFFF" width="120" align="center"> <a href="/redir.php?link=/startups.php" target="_self"><font size="-1">Startup Scripts</font></a></td></tr><tr><td colspan="1" bgcolor="#FFFFFF" width="120" align="center"> <a href="/redir.php?link=/journals/index.php" target="_self"><font size="-1">Techdocs Journals</font></a></td></tr></table></td></tr></table></td></tr></table></td><td><br><table border="0" cellspacing="0" cellpadding="0" width="98%" bgcolor="000000" align="center"><tr><td><table border="0" cellspacing="1" cellpadding="5" width="100%"><tr><td bgcolor="FFFFFF">    <div align="center">
        <b><font size=+3>PostgreSQL 7.3 Set Returning Functions</font></b>
        <br>by <a href="mailto:sszabo@bigpanda.com">Stephan Szabo</a><br>
	    <i>Last updated 4th April 2003</i>
    </div>

    <div class="Section1">
      <p>
        PostgreSQL 7.3 now supports a much more flexible system for
        writing set returning functions (SRFs) that when combined
        with some of the new function permission options allow a
        greater flexibility in setting up schemas. I assume in this
        that you already have some experience with writing
        functions in SQL and PL/pgSQL for PostgreSQL. We're going
        to work with a very simple set of tables and data and
        functions written in SQL and PL/pgSQL. 
      </p>
<pre class="code">
create table department(id int primary key, name text);

create table employee(id int primary key, name text, salary int, departmentid int references department);

insert into department values (1, 'Management');
insert into department values (2, 'IT');

insert into employee values (1, 'John Smith', 30000, 1);
insert into employee values (2, 'Jane Doe', 50000, 1);
insert into employee values (3, 'Jack Jackson', 60000, 2);
</pre>
      <p>
        SRFs can return either a rowtype as defined by an existing
        table or a generic record type. First let's look at a
        simple SQL function that returns an existing table's
        rowtype.
      </p>
<pre class="code">
create function GetEmployees() returns setof employee as 'select * from employee;' language 'sql';
</pre>
      <p>
        This very simple function simply returns all the rows from
        employee. Let's break down this function. The return type
        of the function is <tt class="code">setof employee</tt>,
        meaning it is going to return a rowset of employee rows.
        The body of the function is a very simple SQL statement to
        generate the output rows.
      </p>
      <p>
        An SRF can be used in place of a table or subselect in the
        FROM clause of a query. For example, to use this function
        to get all the information on employees with an id greater
        than 2 you could write:
      </p>
<pre class="code">
select * from GetEmployees() where id &gt; 2;
</pre>
      <p>
        This is great, but what if you wanted to return something
        more complicated, for example, a list of departments and
        the total salary of all employees in that department. If
        you want to return an existing record type, you need to
        make a dummy type to hold the output type, for example:
      </p>
<pre class="code">
create type holder as (departmentid int, totalsalary int8);
</pre>
      <p>
        Here we are defining a new type named holder which is a
        composite type of an integer named <tt class=
        "code">departmentid</tt> and a bigint named <tt class=
        "code">totalsalary</tt>. We can then define functions that
        return sets of this type. For this function we'll write a
        version in SQL and then a version in PL/pgSQL:
      </p>
<pre class="code">
create function SqlDepartmentSalaries() returns setof holder as 
'
    select departmentid, sum(salary) as totalsalary from GetEmployees() group by departmentid
'
language 'sql';
</pre>
<pre class="code">
create or replace function PLpgSQLDepartmentSalaries() returns setof holder as 
'
declare
    r holder%rowtype;
begin
    for r in select departmentid, sum(salary) as totalsalary from GetEmployees() group by departmentid loop
        return next r;
    end loop;
    return;
end
' 
language 'plpgsql';
</pre>
      <p>
        The SQL is very similar to the <tt class=
        "code">GetEmployee()</tt> function above. It returns a
        rowset of rows defined by the type holder (int, int8). The
        rows that it returns are defined by the group by query in
        its body.
      </p>
      <p>
        The PL/pgSQL function is a little more complicated, but
        let's go through it. The function starts off by declaring a
        variable <tt class="code">r</tt> to be of the rowtype
        holder. This variable will be used to store the rows coming
        from the query in the main body of the function. The main
        body does a loop over the group by query stated setting
        <tt class="code">r</tt> to each row in sequence. The body
        of the loop is the new return form, '<tt class=
        "code">return next</tt>' which means that an output row is
        queued into the return set of the function. This does not
        cause the function to return. Currently, SRF returning
        PL/pgSQL functions must generate the entire result set
        before returning although if the set becomes large it will
        be written to disk. This limitation may be removed in a
        future version.
      </p>
      <p>
        These functions are used in the same fashion as the first
        function,
      </p>
<pre class="code">
select * from PLpgSQLDepartmentSalaries();
</pre>
      <p>
        A PL/pgSQL function can also do additional operations on
        the records or only queue up only some records. For
        example, if you wanted to get an idea of operating expenses
        for departments where the overhead is 75% for departments
        whose total salaries were greater than 70,000 and 50%
        otherwise and only wanted to return department ids for
        departments whose salaries plus overhead was greater than
        100,000 you might write something like:
      </p>
<pre class="code">
create or replace function ExpensiveDepartments() returns setof int as 
'
declare
    r holder%rowtype;
begin
    for r in select departmentid, sum(salary) as totalsalary
        from GetEmployees() group by departmentid loop

        if (r.totalsalary &gt; 70000) then
            r.totalsalary := CAST(r.totalsalary * 1.75 as int8);
        else
            r.totalsalary := CAST(r.totalsalary * 1.5 as int8);
        end if;

        if (r.totalsalary &gt; 100000) then
            return next r.departmentid;
        end if;

    end loop;
    return;
end
' 
language 'plpgsql';
</pre>
      <p>
        Let's look at the differences between this and
           <tt class="code">PLpgSQLDepartmentSales()</tt>. This
           function returns a set of integers (department ids)
           rather than a set of a composite type because we only
           need to return the id for the expensive departments. The
           major changes to the workings of the function are inside
           the loop, so let's look more closely.
      </p>
<pre class="code">
        if (r.totalsalary &gt; 70000) then
            r.totalsalary := CAST(r.totalsalary * 1.75 as int8);
        else
            r.totalsalary := CAST(r.totalsalary * 1.5 as int8);
        end if;
</pre>
      <p>
        Here we're figuring out the total salary plus the overhead
        and updating the record appropriately. Next, we want to
        determine if the totalsalary is now greater than 100,000
        and if so return it's identifier, so
      </p>
<pre class="code">
        if (r.totalsalary &gt; 100000) then
            return next r.departmentid;
        end if;
</pre>
      <p>
        Note that for the return next we are not returning the
        record r, but instead are returning just the departmentid
        because this function returns a set of integers. If we
        instead had wanted to return a holder to include the salary
        + overhead value, we could have defined the function to
        return <tt class="code">setof holder</tt> and used
        <tt class="code">return next r;</tt> here.
      </p>
      <p>
        So far, the composite type returning functions only work if
        you're certain that you're returning a type that is made up
        of the same types as the one the function is declared to
        return. If you make a mistake, you'll get an error at
        creation time for SQL functions and at execute time for
        PL/pgSQL functions. But what happens if you only know what
        the details of the composite type the function needs to
        return at execution time? In that case, you can return a
        <tt class="code">setof record</tt>. This tells PostgreSQL
        that you want to the function to return an composite type
        but that you're going to tell it what types to expect
        later.
      </p>
      <p>
        Let's make a function that returns all the rows of a table
        whose name you pass in as a parameter.
      </p>
<pre class="code">
create or replace function GetRows(text) returns setof record as
'
declare
    r record;
begin
    for r in EXECUTE ''select * from '' || $1 loop
        return next r;
    end loop;
    return;
end
'
language 'plpgsql';
</pre>
      <p>
        Calling this function is a little more complicated than
        calling the SRFs above. We need to give the system an idea
        of what types we expect this function to return as part of
        the query. PostgreSQL treats these functions somewhat
        similarly to table subselects and uses a similar syntax for
        providing this information as one would use to give aliases
        to subselect columns.
      </p>
<pre class="code">
select * from GetRows('Department') as dept(deptid int, deptname text);
</pre>
      <p>
        Here we've passed in <tt class="code">Department</tt> as
        the argument which means that we expect to get rows in the
        general form of Department records which is an integer
        followed by a text string, so we tell PostgreSQL that the
        alias for the result should be called <tt class=
        "code">dept</tt> and that it is made up of an integer named
        <tt class="code">deptid</tt> and a text named <tt class=
        "code">deptname</tt>.
      </p>
      <p>
        Finally, we're going to make PL/pgSQL functions that
        synthesize rows completely from scratch. Let's do something
        very simple, a function that returns the numbers from 1 to
        an argument and those numbers doubled. The first version
        uses a pre-defined type as its return type and internal
        type.
      </p>
<pre class="code">
create type numtype as (num int, doublenum int);


create or replace function GetNum(int) returns setof numtype as 
'
declare
    r numtype%rowtype;
    i int;
begin
    for i in 1 .. $1 loop
        r.num := i;
        r.doublenum := i*2;
        return next r;
    end loop;
    return;
end
'
language 'plpgsql';
</pre>
      <p>
        It's pretty simple. The function makes a variable of the
        rowtype numtype and for each number from 1 to the passed
        argument assigns num and doublenum and then does
           <tt class="code">return next r;</tt> in order to enqueue
           a row of output. We can do the same thing using a record
           type so that we do not need an outside type, however it
           is much more complicated and involves a bogus select.
      </p>
    </div>




<hr><b>2003/01/13 08:19 EST (via web):</b><br>
...it would still be nice just to see how the last example could be done with a RECORD type.

<hr><b>2003/01/13 13:43 EST (via web):</b><br>
You have to do something like (given r as record type and returning setof record):
 select into r 1::int as num, 1::int as doublenum;
before using r in the for loop.  It's pretty ugly and
when I did the discussion at SFPUG it was pretty 
unanimous that it was a bad hack and pretty much the
wrong way to go about solving the problem. :)

<hr><b>2003/01/14 01:25 EST (via web):</b><br>
Thank You. Please keep on adding to this section. The other documentation is
very weak on this subject

<hr><b>WarMage 2003/01/28 08:04 EST (via web):</b><br>
If I create a function that insert something but returns nothing (or a success/error code) how would I go about it? Here is an example of my probem :
<br>
No-return function (If possible)
<br><p><span style='font-family:Courier'>
create function InsertEmployee(int,text,int,int) returns ??? as '<br>
insert into employee values ($1, $2, $3, $4);<br>
'  language 'SQL'</span></p><br>
<br>
status return function
<br><p> <span style='font-family:Courier'>
create function InsertEmployee(int,text,int,int) return int as '<br>
insert into employee values ($1, $2, $3, $4);<br>
        //How do i capture any errors???<br>
        //if no errors return success [0] else error code or something<br>
'  language 'SQL'</span></p><br>
<br>
Any help will be apreciated as i am still very new to postgresql
<br>
warmage@magicmail.co.za
<br>
<hr><b>justinc, 2003/01/28 16:35 EST (via web):</b><br>
It would be really nice if someone (other than me) with a bit of spare time would hit the "Edit this page" link at the top of this page and fix up the comments and properly line up the examples.

<hr><b>2003/02/27 11:27 EST (via web):</b><br>
To Warmage: In 7.3, I believe you can make a function return void if you don't want to use its value.  Technically I think you still get a result set containing a NULL, but you don't have to use a final select.  As for status return, if there's an error (excepting a foreign key violation that is not yet checked - like deferred constraints) right now the statement will be ended so it won't get to the next statement in the function.  

<hr><b>2003/03/10 08:37 EST (via web):</b><br>
Technical Assistance is available through the PostgreSQL Mailing Lists, available here:<br><br>

http://www.postgresql.org/lists.html

<hr><b>2003/03/14 18:39 EST (via web):</b><br>
If you call your set-returning function the wrong way (IOW the way you might normally call a function), you will get this error message: Set-valued function called in context that cannot accept a set.
Incorrect: select sr_func(arg1, arg2, ...);
Correct: select * from sr_func(arg1, arg2, ...);

<hr><b>2003/03/29 13:52 EST (via web):</b><br>
GREAT!!!  Its a great HELP!!!

<hr><b>2003/04/01 18:21 EST (via web):</b><br>
Perfect!
Now, what about some samples of functions that return sets in C language?

<hr><b>2003/04/04 15:21 EST (via web):</b><br>
For a C language one, I believe dblink in contrib does C language functions that return a set of tuples.

<hr><b>2003/04/17 03:39 EST (via web):</b><br>
I got problem while I try to use function in a Select query :
i get>
error executing query
declare mycursor for select * from GetEmlpoyees() WHERE id > 2 ;

PostgreSQL error message:
ERROR: parser parse error at or near "("

PostgreSQL status:PGRES_FATAL_ERROR

Does anyone know why i can't use function in a Query ?

<hr><b>2003/04/17 05:51 EST (via web):</b><br>
Add your comments here...

<hr><b>2003/04/17 05:53 EST (via web):</b><br>
How can I cath the system errors that plpgsql return ??
If someone know that please contact me at:
nmogas@xlm.pt
 

<hr><b>2003/04/24 14:52 EST (via web):</b><br>
It´s very important tutorial because many people don´t know how crete that type of functions(procedures), and the way to make it on PostgreSQL is so diferent with other RDBMS such as MSSQL, ORACLE, INFORMIX, INTERBASE/FIREBIRD etc.. This tutorial must become part of Postgresql Function Documentation, with more examples in many other languages than SQL and PL/PGSQL such as Python, Perl, C, etc...

<hr><b>2003/04/24 16:44 EST (via web):</b><br>
Note that if you don't fill in all the values for the return type for each return next, old values will be used, so you have to manually null them. This becomes an issue when denormalizing data which is too complex to handle with a select, and so must be done with nested 'for select in' loops. I run into this most often when creating complex pivot tables that do not use agrigates.  I would like to see 'return next' push the return row, then set all columns to null, ready for fresh data.

The following simplified example shows what I'm talking about (I know this could be done with sub-selects, but in more complicated cases it must be done interatively):

create type returntype as
(
     a int,
     b int,
     c_type1 varchar,
     c_type2 varchar,
     d_type1 varchar
     d_type2 varchar
);

create function tst_func() returns setof returntype as
'
declare
    r returntype%rowtype;
    rLoopA RECORD;
    rLoopB RECORD;
begin

    for rLoopA IN
      select a, b from foo where argle
    loop

        r.a := rLoopA.a;
        r.b := rLoopA.b;    

        for rLoopB IN
          select distinct on (foo, bar) foo, bar, data from sometable where bargle
   -- this select may return a row for for every column of returntype
   -- if a row/column is not returned, it should show null in the result set
        loop

            if foo = type1 and bar = c then
                r.c_type1 :=  rLoopB;
            else
                r.c_type1 := NULL; -- note the explicit set to null
            end if;

            if foo = type2 and bar = c then
                r.c_type2 :=  rLoopB;
            else
                r.c_type2 := NULL;
            end if;

            if foo = type1 and bar = d then
                r.d_type1 :=  rLoopB;
            else
                r.d_type1 := NULL;
            end if;

            if foo = type2 and bar = d then
                r.d_type2 :=  rLoopB;
            else
                r.d_type2 := NULL;
            end if;

        end loop;
        
        return next r;

    end loop;


end;
' language 'plpgsql';

<hr><b>2003/04/24 16:48 EST (via web):</b><br>
Sorry, forgot the pre /pre around my code. Here it is again.

<pre class="code">
The following simplified example shows what I'm talking about 
(I know this could be done with sub-selects, but in more complicated 
cases it must be done interatively):

create type returntype as
(
     a int,
     b int,
     c_type1 varchar,
     c_type2 varchar,
     d_type1 varchar
     d_type2 varchar
);

create function tst_func() returns setof returntype as
'
declare
    r returntype%rowtype;
    rLoopA RECORD;
    rLoopB RECORD;
begin

    for rLoopA IN
      select a, b from foo where argle
    loop

        r.a := rLoopA.a;
        r.b := rLoopA.b;    

        for rLoopB IN
          select distinct on (foo, bar) foo, bar, data from sometable where bargle
   -- this select may return a row for for every column of returntype
   -- if a row/column is not returned, it should show null in the result set
        loop

            if foo = type1 and bar = c then
                r.c_type1 :=  rLoopB;
            else
                r.c_type1 := NULL; -- note the explicit set to null
            end if;

            if foo = type2 and bar = c then
                r.c_type2 :=  rLoopB;
            else
                r.c_type2 := NULL;
            end if;

            if foo = type1 and bar = d then
                r.d_type1 :=  rLoopB;
            else
                r.d_type1 := NULL;
            end if;

            if foo = type2 and bar = d then
                r.d_type2 :=  rLoopB;
            else
                r.d_type2 := NULL;
            end if;

        end loop;
        
        return next r;

    end loop;


end;
' language 'plpgsql';
</pre>

<hr><b>sszabo, 2003/05/15 19:18 EST (via web):</b><br>
I'd think it'd be better to have a way to set the rowtype explicitly (perhaps to a row value constructor) since there's also cases where setting the fields to NULL is explicitly what you don't want.

<hr><b>2003/05/26 08:05 EST (via web):</b><br>
When i want to try run the last example

create type numtype as (num int, doublenum int);


create or replace function GetNum(int) returns setof numtype as 
'
declare
    r numtype%rowtype;
    i int;
begin
    for i in 1 .. $1 loop
        r.num := i;
        r.doublenum := i*2;
        return next r;
    end loop;
    return;
end
'
language 'plpgsql';

It doesnt work....
It give me this error:
WARNING:  Error occurred while executing PL/pgSQL function getnum
WARNING:  line 8 at return next
ERROR:  Set-valued function called in context that cannot accept a set

Is there any one can tell me what wrong with it???


<hr><b>2003/05/27 11:31 EST (via web):</b><br>
Are you calling it like select GetNum(1); or select * from GetNum(1); ?

<hr><b>2003/05/28 11:34 EST (via web):</b><br>
Yes, I agree.. This tutorial must become part of Postgresql Function Documentation. Im confuse about set returning function when read Documentation, but after surf www.postgresql.org , search, found this tutorial, Im glad ... Thx

<hr><b>2003/05/29 08:00 EST (via web):</b><br>
i'm calling it as select * from GetNum(1);

<hr><b>2003/06/04 08:12 EST (via web):</b><br>
Add your comments here...

<hr><b>2003/06/26 04:31 EST (via web):</b><br>
Calling function GetRows(text) error:
testdb=# select * from GetRows('department') as dept(deptid integer, deptname text);
ERROR:  parser: parse error at or near "("
testdb=#

why?

<hr><b>2003/06/26 12:13 EST (via web):</b><br>
I agree This document should be in PostGre documentation.
Do you now a better way to create the type of the result type of the function.
In fact, it's a dammage to declare a type with explicit type when we already knows the type return by the function.
a better way to create the type would be, according to your example :

create type holder as (departmentid employe.departmentid%type, totalsalary int8);

Do you know if there is a way to do that ?




<hr><b>2003/06/30 08:25 EST (via web):</b><br>
There seems to be some limitation with plpgsql that prevents you from using a set-valued function in the  SELECT list of a query. you can do "select foo, set_of_things(bar) from mytable" if set_of_things() is an SQL function, or a C function apparently - this started from trying to figure out how the int_array_enum() function in contrib/intagg got away with it - but not if it's a PL/pgSQL function. However, that does give you a workaround: you can call the PL/pgSQL function *from* an SQL
function. A simplistic example:

create function pfoo(int) returns setof int language 'plpgsql' as 'declare b alias for $1; x int; begin for x in 1..b loop return next x; end loop; return; end;';
create function foo(int) returns setof int language 'sql' as 'select * from pfoo($1)';
select 1, pfoo(5); /* will give you an error */
select 1, foo(5); /* works */

(sorry for formatting this text box is tooo wide and tooo short...)

<hr><b>2003/10/14 18:11 EST (via web):</b><br>
If I create a sql string and the number of column are dynamicaly determined,
then how I can execute the string created? In fact setof implies that I know 
the kind of record, but this information is know only at runtime.

<hr><b>2003/10/15 03:23 EST (via web):</b><br>
Hi,
<br>
as I am new to postgreSQL and functions, I try to execute the first example given above GetEmployees().
<br>
I have created the tables and records as shown above but I cant get the function run. 
<br>
If I give a 
<pre>
SELECT GetEmployees();
</pre>
I get a list of obvious numbers. That might be ok. But If I give a 
<pre>
SELECT * from GetEmployees(); 
</pre>
then I get a ---> 
<pre>
ERROR: parser: parse error at or near "(".
</pre>

Does someone know what is wrong with the example? I am using postgreSQL version 7.2.2
<br>
Thank you.

<hr><b>2003/10/17 19:26 EST (via web):</b><br>
Newbie:

This article requires PostgreSQL version 7.3 or greater.  You can't do it in 7.2.

-Josh

<hr><b>2003/10/24 05:22 EST (via web):</b><br>
Fixed the ANNOYING formatting of this page.
Someone had wrapped their entire comment in pre /pre and made the page layout confoundingly wide.

<hr><b>2003/10/24 16:45 EST (via web):</b><br>
Just a quick note for a problem I was having. One of my tables has a recursive relationship. old records-> new records. Writing a function that returned the most current row for any given entry point was a little tricky as nothing mentioned recursion that I saw. 

The following is what I did. 

<pre>
create or replace function get_current_rec(numeric) returns setof rec as
'
declare 
  r rec%rowtype;
begin
  for r in select a, b, c, d as total from table where key = $1 loop
    if r.replaced_by IS NULL THEN
      return next r;
    ELSE 
      raise notice ''trying to fetch record for %'',r.replaced_by;
      select into r *  from get_current_rec(r.replaced_by);
      return next r;
    end if;
    end loop;
  return;
end
'
language 'plpgsql';
</pre>

For the longest time I was stuck on getting 0 records back. Turns out selecting into r and calling next fixed that. I've tested this with 4 levels of recursion so far and its worked, so I believe it is correct. 



<hr><b>2003/10/24 17:31 EST (via web):</b><br>
Is there a way to have a function return an agregate of custom types?

Something like: 

<pre>
create type foo as (blah int, blum int);
create type bar as (words text, when timestamp);
create type things as (foo, bar);

create function something() returns setof things as '
  statements;
'

</pre>

<hr><b>2003/10/25 15:33 EST (via web):</b><br>
Does anyone have an example of a C function which returns a SETOF RECORD?  [tablefunc.c does this, but for a ROWTYPE, not a RECORD]
What would be the syntax for calling this?  [Maybe:  SELECT * FROM c_fcn() AS (a int, b text);]

<hr><b>2003/11/03 00:12 EST (via web):</b><br>
Thanks, this helped quite a bit.

A caviat: if you are dealing with a WHERE clause in the EXECUTE SELECT, you may want to quote_literal() your string variables (if they are being passed in).  For example:

CREATE FUNCTION public.sp_get_baz_for_cust(bpchar) RETURNS  SETOF bpchar AS '
DECLARE cust_id      ALIAS FOR $1;
        baz_num      CHAR( 15 );
        selected_baz RECORD;

BEGIN

FOR selected_baz IN EXECUTE ''SELECT baz_number FROM baz_table WHERE customer_id = '' || quote_literal( cust_id )  LOOP
     RETURN NEXT selected_baz.ticket_number;
END LOOP;

RETURN;

END;

Without quote_literal(), the query tends to choke on special characters (like colons, dashes, et. al.)  I think it won't like spaces much either.  I tried building the string as ''SELECT baz_number FROM baz_table WHERE customer_id = '''' || cust_id || '''''' - no dice.  quote_literal() was the solution.

<hr><b>2003/11/03 00:16 EST (via web):</b><br>
Sorry for the spooge in the last posting.  My first here and didn't realize I'd need to format.  Here it is again in (hopefully) a bit friendlier format:
<BR><BR>
Thanks, this helped quite a bit.
<BR><BR>
A caviat: if you are dealing with a WHERE clause in the EXECUTE SELECT, you may want to quote_literal() your string variables (if they are being passed in).  For example:
<BR><BR>
CREATE FUNCTION public.sp_get_baz_for_cust(bpchar) RETURNS  SETOF bpchar AS '<BR>
DECLARE cust_id&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ALIAS FOR $1;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;baz_num&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CHAR( 15 );<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;selected_baz RECORD;<BR>
<BR>
BEGIN<BR>
<BR>
FOR selected_baz IN EXECUTE ''SELECT baz_number FROM baz_table WHERE customer_id = '' || quote_literal( cust_id )  LOOP<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RETURN NEXT selected_baz.ticket_number;<BR>
END LOOP;<BR>
<BR>
RETURN;<BR>
<BR>
END;<BR>
<BR>
Without quote_literal(), the query tends to choke on special characters (like colons, dashes, et. al.)  I think it won't like spaces much either.  I tried building the string as ''SELECT baz_number FROM baz_table WHERE customer_id = '''' || cust_id || '''''' - no dice.  quote_literal() was the solution.</td></tr></table></td></tr></table>
<br>
<table border="0" cellspacing="0" cellpadding="0" width="98%" bgcolor="000000" align="center"><tr><td><table width="100%" cellspacing="1" cellpadding="3" border="0"><tr><td bgcolor="FFFFFF" align="center">
<!-- Comment Form -->
<form method="POST" action="http://techdocs.postgresql.org/guides/SetReturningFunctions/" enctype="multipart/form-data">
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td align="right" colspan="2">
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td align="center" bgcolor="#dddddd">
<textarea wrap="virtual" name="text" rows=3 cols=60 style="width:100%; title="enter comments here & click add; or, click edit" accesskey="c">Add your comments here...</textarea>
</td></tr></table>

</td></tr><tr><td align="left" valign="top" width="20%" nowrap>&nbsp;</td>

<td align="right" valign="top" width="80%">
<b><input type="submit" name="comment:method" value="Add a comment" style="font-weight:bold"></b><br>
<input type="hidden" name="use_heading" value="1">

</td></tr></table></form>
<!-- End of Comment Form -->
</td></tr></table></td></tr></table>
<br>
<!-- Dislaimer -->
<table border="0" cellspacing="0" cellpadding="0" width="98%" bgcolor="000000" align="center"><tr><td><table width="100%" cellspacing="1" cellpadding="3" border="0"><tr><td bgcolor="FFFFFF" align="center">If you're having problems with an aspect of PostgreSQL, the first place to look for assistance is in the Mailing list archives at <a href="http://archives.postgresql.org" target="_blank">http://archives.postgresql.org</a><br><br>If that doesn't work, you can join the PostgreSQL "General" mailing list and ask for assistance there.&nbsp;&nbsp;Details for joining this mailing list can be found at the <a href="/redir.php?link=http://www.ca.postgresql.org/users-lounge/index.html" target="_blank">PostgreSQL Users Lounge</a>.<br><br>Just in case that doesn't work for you either, we have an #postgresql IRC Channel on FreeNode (irc.freenode.net), you're welcome to ask questions there.<br><br>Additional submissions for this website are welcome.&nbsp;&nbsp;The more detail the better.&nbsp;&nbsp;Please email them to <a href="/redir.php?link=mailto:justin@postgresql.org" target="_blank">justin@postgresql.org</a>.</td></tr><tr><td bgcolor="#FFFFFF" align="center"><p>Whilst this information is accurate to the best of my knowledge, some things may work differently for you and neither I nor any member of the PostgreSQL community can be held responsible for any losses or damage which may occur.</p></td></tr><tr><td bgcolor="#FFFFFF" align="center"><p>All content for the PostgreSQL Guides, unless otherwise marked, is Copyright &copy; 2002 PostgreSQL Global Development Group.<br>All rights reserved.</p></td></tr></table></td></tr></table>

<br></td></tr></table></td></tr></table></body></html>